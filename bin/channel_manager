#!/usr/bin/perl -w

use strict;
use DBI;
use Getopt::Long;
use List::MoreUtils qw/ uniq /;
use File::Slurp;

use lib './lib';
use MythConverg::Schema;

my $dbhost="127.0.0.1";
my $database="mythconverg";
my $user="mythtv";
my $pass="mythtv";
my $hidden = 0;
my $scan="channels.conf";
my $conf="contrib/freesat.csv";
my $videosource = "xmltv";

GetOptions('dbhost=s'=>\$dbhost,
           'database=s'=>\$database,
           'user=s'=>\$user,
           'pass=s'=>\$pass,
           'hidden!'=>\$hidden,
	   'scan=s'=>\$scan,
	   'conf=s'=>\$conf,
	   'videosource=s'=>\$videosource
           ) || die "Usage:";

# read config file
my @conf_chans_file = read_file $conf;
die "Config file '$conf' is empty!\n"
    if 0 == scalar @conf_chans_file;

# put details into hashref
my %config_chans;
foreach my $line (@conf_chans_file) {
    chomp($line);
    my ($channum, $callsign, $xmltvid, $sid)  = split(',',$line);
    $config_chans{$sid} = {
	channum => $channum,
	callsign => $callsign,
	xmltvid => $xmltvid,
	sid => $sid
    };
}

# read scanned channels
my @scanned_chans_file = read_file $scan;
die "Config file '$scan' is empty!\n"
    if 0 == scalar @scanned_chans_file;

# put scanned channels into hashref
my %scanned_chans;
foreach my $line (@scanned_chans_file)
{
    chomp($line);
    my $scan = parse_vdr_line($line);

    # put into hashref
    $scanned_chans{$scan->{sid}} = $scan;
}

# connect to db
my $s = MythConverg::Schema->connect(
    'dbi:mysql:database=mythconverg',
    'mythtv', $pass,
    { mysql_enable_utf8 => 1, quote_char => q{`}, name_sep => q{.} },  
);

# get some tables
my $sources = $s->resultset('Videosource');
my $channels = $s->resultset('Channel');
my $multiplexes = $s->resultset('DtvMultiplex');

# Check video source and get sourceid.
my $source = $sources->find({name => $videosource})
    or die "Unknown video source '$videosource' (use -s <sourcename>).\n";
my $sourceid = $source->sourceid;


# First we should set all channels to be not visible

# for each entry in config_channels, see if it exists in the database
foreach my $sid (keys %config_chans) {

    # Get current config channel
    my $config_chan = $config_chans{$sid};

    # Find corresponding channel in scan data
    my $scanned_chan = $scanned_chans{$sid};

    # If channel can't be found, try searching on callsign and then die
    if (!defined($scanned_chan) || ($config_chan->{callsign} ne $scanned_chan->{cs})) {
	my @name_matches = grep { $scanned_chans{$_}->{cs} eq ($config_chan->{callsign}) } keys %scanned_chans;
	
	if (scalar @name_matches < 1) {
	    print "$config_chan->{callsign} ($sid): no match on ServiceID or name\n";
	} elsif (scalar @name_matches eq 1) {
	    print "$config_chan->{callsign} ($sid): ServiceID changed to @name_matches\n";
	} else {
	    print "$config_chan->{callsign} ($sid): ServiceID changed.  Multiple name matches: " . join(',', @name_matches) . "\n";
	}

	die  "Config channel $config_chan->{channum} ($config_chan->{callsign}) not found in scan! Please fix config.\n";
    }

    # Look for matching channel in db, checking serviceid and callsign
    my @db_chans = $channels->search({serviceid => $sid});

    # Bail out if there are multiple channels with the same service id
    die "Multiple channels in database with serviceid $sid!\n"
	if scalar @db_chans > 1;

    # Found one possible match.  Check callsign.
    if (scalar @db_chans eq 1) {

	my $db_chan = $db_chans[0];
	my $db_callsign = $db_chan->callsign;
	$db_callsign =~ s/:/ /g;

	if ($db_callsign eq $config_chan->{callsign}) {

	    # Have a good match in the database
	    my $db_mplex = $multiplexes->find({mplexid => $db_chan->mplexid});
	    my $params = $scanned_chan->{__parameters__};

	    if ((abs($db_mplex->frequency / 1000 - $scanned_chan->{freq}) < 5) &&
		($db_mplex->polarity eq $params->{polarity}) &&
		($db_mplex->modulation eq $params->{modulation}) &&
		($db_mplex->fec eq $params->{fec})) {

		# Everything OK.  Set channel visible.
		$db_chan->update({visible => 1});

	    } else {

		# Serviceid/callsign match but tuning data are different.  Update/create multiplex and change mplexid in channel table and set visible
		print "Tuning details differ for $config_chan->{callsign} (SID: $config_chan->{sid}).  Updating multiplex.\n";

		my $mplex = find_multiplex($multiplexes, $scanned_chan);
		$db_chan->update({
		    mplexid => $mplex->mplexid,
		    visible => 1
				 });
	    }
	} else {
	    # Don't have a match on callsign or serviceid
	    die "Barfed because sid in db has wrong callsign\n";
	}
    } else {

	print "Config channel $config_chan->{callsign} (SID: $config_chan->{sid}) missing from database.  ";

	# Config channel doesn't have a direct match on callsign and serviceid.  Search by callsign for outdated record.
	my @db_chans = $channels->search({callsign => $config_chan->{callsign}});
	print "Found " . scalar @db_chans ." matches on callsign.  Updating details.\n";

	# If we have only one match, try to fix it up.  Otherwise die.
	die "Found too many matches on callsign to continue.\n"
	    if scalar @db_chans > 1;

	if (scalar @db_chans eq 1) {
	    # Find correct multiplex using scan data.  Update serviceid and mplexid and set visible.
	    my $mplex = find_multiplex($multiplexes, $scanned_chan);

	    my $db_chan = $db_chans[0];
	    $db_chan->update({
		serviceid => $sid,
		mplexid => $mplex->mplexid,
		visible => 1
			     });
	} else {
	    # Add a new channel entry
	}

    }
}

# Check some option and then delete any invisible channels.

sub parse_vdr_line {
    my $line = shift;

    # http://linuxtv.org/vdrwiki/index.php/Syntax_of_channels.conf
    # callsign;bouquet:frequency:params():source:symbolrate:vpid:apid:textpid:conditional:serviceid:networkid:transportid:radioid
    # Channel 4;BSkyB:10714:hC56:S28.2E:22000:2327:2328:2329:0:9212:2:2041:0
    # Channel 4;Channel 4 TV:650166:I999B8C23D12M64T2G32Y0:T:27500:560:561=eng,562=eng:0:0:8384:9018:8207:0

    my ($cs,$freq,$params,$src,$sr,undef,undef,undef,undef,$sid,$nid,$tid,undef)
        = ($line =~ m/([^:]+):?/g);

    # general fixups
    $cs =~ s/;.+//;
    $src =~ s/^(.).*/$1/;

    # satellite params
    (my $pol = $params) =~ s{.*([hv]).*}{$1}i;
    $pol = (length $pol > 1 ? undef : lc $pol);
    (my $fec = $params) =~ s{.*C(\d)(\d).*}{$1/$2}; # breaks for 0, so...
    $fec ||= 'auto';
    (my $mod_tmp = $params) =~ s{.*M(\d+).*}{$1};
    my $mod_sat = ($mod_tmp eq 2 ? "qpsk" : "8psk");
    (my $rolloff = $params) =~ s{.*O(\d+).*}{$1};
    $rolloff /= 100;

    # terrestrial params
    (my $inv = $params)  =~ s{.*I(\d+).*}{$1};
    $inv = ($inv eq 1 ? $inv : 'auto');
    (my $hp = $params)   =~ s{.*C(\d)(\d).*}{$1/$2}; # breaks for 0, so...
    $hp ||= 'auto';
    (my $lp = $params)   =~ s{.*D(\d)(\d).*}{$1/$2}; # breaks for 0, so...
    $lp ||= 'auto';
    (my $mod = $params)  =~ s{.*M(\d+).*}{qam_$1};
    $mod ||= 'auto';
    (my $bw = $params)   =~ s{.*B(\d).*}{$1};
    (my $tmde = $params) =~ s{.*T(\d).*}{$1};
    (my $grd = $params)  =~ s{.*G(\d+).*}{1/$1};
    (my $hrch = $params) =~ s{.*Y(\d).*}{$1};
    $hrch ||= 'n';

    return {
        cs => $cs,
        freq => $freq,

        '__parameters__' => ($src eq 'S' ? {
            fec => $fec,
            polarity => $pol,
            mod_sys => 'DVB-S',
	    modulation => $mod_sat,
	    constellation => $mod_sat,
	    rolloff => $rolloff,
	    hierarchy => 'a',
        } : {
            inversion => $inv,
            hp_code_rate => $hp,
            lp_code_rate => $lp,
            modulation => $mod,
            constellation => $mod, # guess?!
            bandwidth => $bw,
            transmission_mode => $tmde,
            guard_interval => $grd,
            hierarchy => $hrch,
        }),

        src => $src,
        sr => $sr,
        sid => $sid,
        nid => $nid,
        tid => $tid,
    };
}

sub find_multiplex {

    my $multiplexes = shift(@_);
    my $scanned_chan = shift(@_);

    my $use_freq = $scanned_chan->{freq} < 1_000_000 ? $scanned_chan->{freq} * 1_000 : $scanned_chan->{freq};
    my $mplex = $multiplexes->find_or_create(
	{
	    sourceid => $sourceid,
	    frequency => {
		-between => [
		     $use_freq - 2500,
		     $use_freq + 2500,
		    ],
	    },
		    symbolrate => ($scanned_chan->{sr} < 1_000_000 ? $scanned_chan->{sr} * 1_000 : $scanned_chan->{sr}),
		    transportid => $scanned_chan->{tid},
		    networkid => $scanned_chan->{nid},
		    %{ $scanned_chan->{'__parameters__'} }
	});

    return $mplex;
}
